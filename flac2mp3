#!/usr/bin/perl -w
#
# flac2mp3.pl
#
# Version 0.2.1
#
# Converts a directory full of flac files into a corresponding directory of mp3 files
#
# Usage:
#
#   flac2mp3.pl [options] srcdir destdir
#
# Robin Bowes <robin@robinbowes.com>
#
# Revision History:
#
# v0.2.1
#  - Bug-fix: omitted File::Path module include
# v0.2.0
#  - Only create directories if files are found in them
#  - Make output less cluttered (only display filenames, not whole path)
#  - Changed command-line options.
#  - Major overhaul of tag handling. Now using MP3::Tag module
#    to write tags to mp3 files. Allows tags to be read separately
# v0.1.4
#  - Fix for files with multiple periods in filename, e.g. "01 - Back In
#    The U.S.S.R..flac" would be converted as "Back In The U.mp3"
#  - Fix for timestamp comparison (got it the right way round this
#    time!)
# v0.1.3
#  - added --quiet option to flac and lame commands
#  - only run conversion if dest file doesn't exist or if src file is
#    newer than dest file
#  - set modification time of dest file to same as src file
#  - check exit value of conversion command
#  - fixed problem with certain characters in file/directory name
#  - added rudimentary SIGINT handling
# v0.1.2
#  - Fixed filename quoting
# v0.1.1
#  - Changes to filename quoting
# v0.1.0
#  - Initial version
#
# To-do:
#  - Extend to apply all legal tags in FLAC field (esp. Composer, Conductor, etc.)
#  - Still falls over with certain characters in filename, e.g.
#    Rock `N' Roll Suicide.flac
#  - Clean up filepaths (check for double // in dirnames)
#  - Clean up and rationalise program output, e.g. produce a sensible
#    level of output by default unless a --quiet switch is used
#  - Investigate using Audio::FLAC::Decode and Audio::MPEG instead of
#    flac and lame programs used from system call
#  - Write OO Audio file objects that know how to decode/encode/get
#    tags/set tags for themselves - should open up the way to allow for
#    transcoding between additional formats.
#  - Write README file and bundle flac2mp3.pl into a tarball
#  - Write "Usage" method to document command-line switches
#  - google for a standard perl script template include things like
#    options, pod, GPL statement, how to set program version, etc. etc.

use strict;
use Audio::FLAC::Header;
use Data::Dumper;
use File::Basename;
use File::Path;
use File::Spec;
use File::stat;
use Getopt::Long;
use MP3::Tag;

our $flaccmd = "/usr/bin/flac";
our $lamecmd = "/usr/bin/lame";
our @flacargs = qw ( --decode --stdout --silent);

# Build this array dynamically from command-line options
# Add --quiet option by default?
our @lameargs = qw ( --preset standard  --replaygain-accurate --quiet);

# FLAC/MP3 tag mapping
# Flac: 	ALBUM  ARTIST  TITLE  DATE  GENRE  TRACKNUMBER  COMMENT
# ID3v2:	ALBUM  ARTIST  TITLE  YEAR  GENRE  TRACK        COMMENT

# hash mapping FLAC tag names to MP3 names
our %MP3Tags = (	'ALBUM'			=> 'TALB',
						'ARTIST'			=> 'TPE1',
						'COMMENT'		=> 'COMM',
						'DATE'			=> 'TYER',
						'GENRE'			=> 'TCON',
						'TITLE'			=> 'TIT2',
						'TRACKNUMBER'	=> 'TRCK',
					);
												
use vars qw ( 	$flag_info
					$flag_debug
					$flag_tagsonly
);

# Catch SIGINTs
$SIG{INT} = \&INT_Handler;

GetOptions (
	"quiet!"		=>	\$flag_info,
	"debug!"		=>	\$flag_debug,
	"tagsonly!"	=>	\$flag_tagsonly
);

# info flag is the inverse of --quiet
$flag_info = !$flag_info;

# Do I need to set the default value of any options? Or does GetOptions handle it?
# If I do, what's the "best" way to do it?

my ($srcdirroot, $destdirroot) = @ARGV;

showusage() if (!defined $srcdirroot || !defined $destdirroot);

die "Source directory not found: $srcdirroot\n"
	unless -d $srcdirroot;

# count all flac files in srcdir
# Display a progress report after each file, e.g. Processed 367/4394 files
# Possibly do some timing and add a Estimated Time Remaining
# Will need to only count files that are going to be processed. Hmmm could get complicated.

find_files($srcdirroot, $destdirroot, $srcdirroot);

1;
## End of main program

sub find_files {
	my ($srcdirroot, $destdirroot, $srcdir) = @_;

	$::flag_info && msg("Processing directory: $srcdir\n");

	# remove the src root directory from the beginning
	# of the current directory to give the additional
	# path information to be added to the destination root.
	# Try to create the new destination directory.
	(my $extra_path = $srcdir) =~ s/^\Q$srcdirroot\E//;
	my $destdir = $destdirroot . $extra_path;

	# get all directory entries
	opendir(SRCDIR, $srcdir) or die "Couldn't open directory $srcdir\n";
	my @direntries = readdir(SRCDIR) or
		die "Couldn't read directory entries for directory $srcdir\n";
	closedir(SRCDIR);

	# get all target files within the present directory
	my @target_files = 	map  { $_->[1] }				# extract pathnames
								map  { [ $_, "$srcdir/$_" ] }	# form (name, path)
								grep { /\.flac$/ }			# just flac files
								@direntries;

	# get all subdirs of the present directory
	my @subdirs =	map  { $_->[1] }						# extract pathnames
						grep { -d $_->[1] }              # only directories
						map  { [ $_, "$srcdir/$_" ] }		# form (name, path)
						grep { !/^\.\.?$/ }					# not . or ..
						@direntries;

	# Create the destination directory if it doesn't already exist
	mkpath($destdir) or die "Can't create directory $destdir\n"
		unless -d $destdir;


	# process all files found in this directory
	foreach my $srcfilename (@target_files) {
		convert_file($srcfilename, $destdir);
	}

	# process any subdirs of present directory
	foreach my $srcsubdir (@subdirs) {
		&find_files($srcdirroot, $destdirroot, $srcsubdir);
	}
}

sub showusage {
	print "Usage goes here\n";
	exit 1;
}

sub msg {
	my $msg = shift;
	print "$msg";
}

sub convert_file {
	my ($srcfilename, $destdir) = @_;
	
		# To do:
		#   Compare tags even if src and dest file have same timestamp
		#   Use command-line switches to override default behaviour
	
	# get srcfile timestamp
	my $srcstat = stat($srcfilename);
	my $deststat;
	
	my $srcRelPath = File::Spec->abs2rel($srcfilename, $srcdirroot);
	
	my $destPath = File::Spec->rel2abs($srcRelPath, $destdirroot);

	my ($fbase, $fdir, $fext) = fileparse( $destPath, '\.flac$' );
	my $destfilename = $fdir . $fbase . ".mp3";
	
	$::flag_debug && msg("srcfile: $srcfilename\n");	
	$::flag_debug && msg("destfile: $destfilename\n");

	# create object to access flac tags
	my $srcfile = Audio::FLAC::Header->new($srcfilename);
	
	# Get tags from flac file
	my $srctags = $srcfile->tags();

	$::flag_debug && print "Tags from source file:\n" . Dumper $srctags;

	# hash to hold tags that will be updated
	my %changedTags;
	
	# weed out tags not valid in destfile
	foreach my $tag (keys %$srctags) {
		if ($MP3Tags{$tag}) {
			$changedTags{$tag} = $srctags->{$tag};
		}
	}
	
	if ($::flag_debug) {
		print "Valid Tags from source file:\n";
		print Dumper \%changedTags;
	}
	
	# File Processing flags
	my $pf_exists = 0;
	my $pf_tags = 0;
	my $pf_timestamp = 1;

	$::flag_debug && msg("destfilename: $destfilename\n");

	# if destfile already exists
	if (-e $destfilename) {
	
		$pf_exists = 1;

		$::flag_debug && msg("destfile exists: $destfilename\n");
		
		# get destfile timestamp
		$deststat = stat($destfilename);
	
		my $srcmodtime = scalar $srcstat->mtime;
		my $destmodtime = scalar $deststat->mtime;

		if ($::flag_debug) {
			print ("srcfile mtime:  $srcmodtime\n");
			print ("destfile mtime: $destmodtime\n");
		}
		
		# Don't process the file srcfile timestamp is earlier than destfile
		# or tags are different
		if ($srcmodtime >= $destmodtime) {
			$pf_timestamp = 0;
		}
		
		$::flag_debug && msg("pf_timestamp: $pf_timestamp\n");

		# If the file dates are the same
		if (!$pf_timestamp) {
			# Compare tags; build hash of changed tags;
			# if hash empty, process the file

			my $destfiletag = get_tag($destfilename, 1);
			
			if (defined $destfiletag) {
				# loop over all valid destfile tags
				foreach my $tag (keys %MP3Tags) {

					$::flag_debug && msg("tag is $tag\n");
			
					# To do: Check the tag is valid
					# Specifically, make sure the GENRE is one of the standard ID3 tags
					my $method = $MP3Tags{$tag};

					$::flag_debug && msg("method is $method\n");
				
					# Check for tag in destfile
					my $desttag = $destfiletag->{$method};
				
					# Check for undefined tag
					if (!defined $desttag) {
						$desttag = '';
					} else {
				
						# Bug: AudioFile::Info returns track as numeric. FLAC returns a string
						# 3 <> 03 so the track tag will always appear modified
						if ($tag eq "TRACKNUMBER") {
							if ($desttag < 10) {
								$desttag = sprintf("%02u", $desttag);
							}
						}
					}
				
					$::flag_debug && msg("desttag value: $desttag\n");

					# get tag from srcfile
					my $srctag = $changedTags{$tag};
					
					$srctag = '' if (!defined $srctag);

					$::flag_debug && msg("srctag value: $srctag\n");
				
					# If tags are the same...
					if ($desttag eq $srctag) {
						# remove from tags to be written hash
						delete($changedTags{$tag});
					} else {
						$pf_tags = 1;
					}
				}
			}
		}
	}

	if ($::flag_debug) {
		msg("pf_exists:    $pf_exists\n");
		msg("pf_tags:      $pf_tags\n");
		msg("pf_timestamp: $pf_timestamp\n");
	}		

	if ($::flag_debug) {
		print "Tags to be written to dest file:\n";
		print Dumper \%changedTags;
	}


	
	if (!$pf_exists || $pf_timestamp || $pf_tags) {
		
		$::flag_info && msg("Processing \"$fbase$fext\"\n");

		if (!$::flag_tagsonly && (!$pf_exists || ($pf_exists && !$pf_tags))) {
			# Building command used to convert file (tagging done afterwards)
			
			# Needs some work on quoting filenames containing special characters
			my $quotedsrc = $srcfilename;
			my $quoteddest = $destfilename;
			my $convert_command = "$flaccmd @flacargs \"$quotedsrc\"" .
				"| $lamecmd @lameargs - \"$quoteddest\"";
	
			$::flag_debug && msg("$convert_command\n");

			
			# Convert the file
			my $exit_value = system ($convert_command);
		
			$::flag_debug && msg("Exit value from convert command: $exit_value\n");
		
			if ($exit_value) {
				print("$convert_command failed with exit code $exit_value\n");
				# delete the destfile if it exists
				unlink $destfilename;
				# should check exit status of this command
			
				exit($exit_value);
			}
			# the destfile now exists!
			$pf_exists = 1;
		}		

		# Write the tags to the converted file
		if ($pf_exists && ($pf_tags || $pf_timestamp)) {

			$::flag_debug && msg("Writing tags to file\n");

			# set the tag variable named $method
			my $desttag = get_tag($destfilename);

			foreach my $tag (keys %changedTags) {

				$::flag_debug && msg("changedTag is $tag\n");
			
				# To do: Check the tag is valid
				# Specifically, make sure the GENRE is one of the standard ID3 tags
				my $method = $MP3Tags{$tag};

				$::flag_debug && msg("method is $method\n");

				my $tagstring = $changedTags{$tag};

				$::flag_debug && msg("Setting $tag = $tagstring\n");
				
				$desttag->{$method} = $tagstring;
			}

			set_tag($destfilename, $desttag);
				
			# should optionally reset the destfile timestamp to the same as the srcfile	
			utime $srcstat->mtime, $srcstat->mtime, $destfilename;
		}
	}
}

sub INT_Handler {
	my $signame = shift;
	die "Exited with SIG$signame\n";
}

# set_tag and get_tag routines taken from articles written by Teodor Zlatanov (tzz@bu.edu)
# Part 1:	http://www-106.ibm.com/developerworks/linux/library/l-cpmp31.html
# Part 2:	http://www-106.ibm.com/developerworks/linux/library/l-cpmp32.html

sub set_tag {

	my $file = shift @_;
	my $tag  = shift @_;
	my $mp3 = MP3::Tag->new($file);
	if ($::flag_debug) {
		print "Tags read from dest file:\n";
		print Dumper $tag;
	}
	my $tags = $mp3->get_tags();
	my $id3v2;
 
	if (ref $tags eq 'HASH' && exists $tags->{ID3v2}) {
		$id3v2 = $tags->{ID3v2};
	} else {
		$id3v2 = $mp3->new_tag("ID3v2");
	}

	my %old_frames = %{$id3v2->get_frame_ids()};
 
	foreach my $fname (keys %$tag) {
		$id3v2->remove_frame($fname)
			if exists $old_frames{$fname};

		if ($fname eq 'WXXX') {
			$id3v2->add_frame('WXXX', 'ENG', 'FreeDB URL', $tag->{WXXX}) ;
		} elsif ($fname eq 'COMM') {
			$id3v2->add_frame('COMM', 'ENG', 'Comment', $tag->{COMM}) ;
		} else {
			$id3v2->add_frame($fname, $tag->{$fname});
		}
	}

	$id3v2->write_tag();
	return 0;
}

sub get_tag {

	my %supported_frames = (
			TIT1 => 1,
			TIT2 => 1,
			TRCK => 1,
			TALB => 1,
			TPE1 => 1,
			COMM => 1,
			WXXX => 1,
			TYER => 1,
	);

	my $file    = shift @_;
	my $upgrade = shift @_;
	my $mp3 = MP3::Tag->new($file);

	return undef unless defined $mp3;

	$mp3->get_tags();

	my $tag = {};

	if (exists $mp3->{ID3v2}) {
		my $id3v2 = $mp3->{ID3v2};
		my $frames = $id3v2->supported_frames();
		Dumper (%$frames);
		while (my ($fname, $longname) = each %$frames) {
			# only grab the frames we know
			next unless exists $supported_frames{$fname};
   
			$tag->{$fname} = $id3v2->get_frame($fname);
			delete $tag->{$fname} unless defined $tag->{$fname};
			$tag->{$fname} = $tag->{$fname}->{Text} if $fname eq 'COMM';
			$tag->{$fname} = $tag->{$fname}->{URL} if $fname eq 'WXXX';
			$tag->{$fname} = '' unless defined $tag->{$fname};
		}
	} elsif (exists $mp3->{ID3v1}) {
		warn "No ID3 v2 TAG info in $file, using the v1 tag";
		my $id3v1 = $mp3->{ID3v1};
		$tag->{COMM} = $id3v1->comment();
		$tag->{TIT2} = $id3v1->song();
		$tag->{TPE1} = $id3v1->artist();
 		$tag->{TALB} = $id3v1->album();
		$tag->{TYER} = $id3v1->year();
		$tag->{TRCK} = $id3v1->track();
		$tag->{TCON} = $id3v1->genre();

#  if ($upgrade) && ($config->ACCEPT_ALL() || read_yes_no("Upgrade ID3v1 tag to ID3v2 for $file?", 1)))
		if ($upgrade) {
			set_tag($file, $tag);
		}
	} else {
		warn "No ID3 TAG info in $file, creating it";
		$tag = {
			TIT1 => '',
			TIT2 => '',
			TPE1 => '',
			TALB => '',
			TYER => 9999,
			COMM => '',
			TCON => '',
		};
	}

	$::flag_debug && print "Got tag ", Dumper $tag;

	return $tag;
}
# vim:set tabstop=3:
