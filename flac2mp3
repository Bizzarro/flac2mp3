#!/usr/bin/perl -w
#
# flac2mp3.pl
#
# Version 0.2.3
#
# Converts a directory full of flac files into a corresponding
# directory of mp3 files
#
# Usage:
#
#   flac2mp3.pl [options] srcdir destdir
#
# Robin Bowes <robin@robinbowes.com>
#
# Revision History:
#
# v0.2.3
#  - Added --force option to force conversion
#  - files/directories now processed alphabetically
#  - Now handles Comments correctly (Comments are complex frames)
#  - Tidied up code with perltidy (http://perltidy.sf.net)
# v0.2.2
#  - Bug-fix: timestamp comparison not quite right
#  - Be more robust when converting files
#    (thanks Darren Warner <darren@dazwin.com>)
# v0.2.1
#  - Bug-fix: omitted File::Path module include
# v0.2.0
#  - Only create directories if files are found in them
#  - Make output less cluttered (only display filenames, not whole path)
#  - Changed command-line options.
#  - Major overhaul of tag handling. Now using MP3::Tag module
#    to write tags to mp3 files. Allows tags to be read separately
# v0.1.4
#  - Fix for files with multiple periods in filename, e.g. "01 - Back In
#    The U.S.S.R..flac" would be converted as "Back In The U.mp3"
#  - Fix for timestamp comparison (got it the right way round this
#    time!)
# v0.1.3
#  - added --quiet option to flac and lame commands
#  - only run conversion if dest file doesn't exist or if src file is
#    newer than dest file
#  - set modification time of dest file to same as src file
#  - check exit value of conversion command
#  - fixed problem with certain characters in file/directory name
#  - added rudimentary SIGINT handling
# v0.1.2
#  - Fixed filename quoting
# v0.1.1
#  - Changes to filename quoting
# v0.1.0
#  - Initial version
#
# To-do:
#  - Extend to apply all legal tags in FLAC field (esp. Composer, Conductor, etc.)
#  - Still falls over with certain characters in filename, e.g.
#    Rock `N' Roll Suicide.flac
#  - Clean up filepaths (check for double // in dirnames)
#  - Clean up and rationalise program output, e.g. produce a sensible
#    level of output by default unless a --quiet switch is used
#  - Investigate using Audio::FLAC::Decode and Audio::MPEG instead of
#    flac and lame programs used from system call
#  - Write OO Audio file objects that know how to decode/encode/get
#    tags/set tags for themselves - should open up the way to allow for
#    transcoding between additional formats.
#  - Write README file and bundle flac2mp3.pl into a tarball
#  - Write "Usage" method to document command-line switches
#  - google for a standard perl script template include things like
#    options, pod, GPL statement, how to set program version, etc. etc.

use strict;
use Audio::FLAC::Header;
use Data::Dumper;
use File::Basename;
use File::Path;
use File::Spec;
use File::stat;
use Getopt::Long;
use MP3::Tag;

our $flaccmd = "/usr/bin/flac";
our $lamecmd = "/usr/bin/lame";

our @flacargs = qw (
  --decode
  --stdout
  --silent
);

# Build this array dynamically from command-line options
# Add --quiet option by default?
our @lameargs = qw (
  --preset standard
  --replaygain-accurate
  --quiet
);

# FLAC/MP3 tag/frame mapping
# Flac: 	ALBUM  ARTIST  TITLE  DATE  GENRE  TRACKNUMBER  COMMENT
# ID3v2:	ALBUM  ARTIST  TITLE  YEAR  GENRE  TRACK        COMMENT
# Frame: TALB   TPE1    TIT2   TYER  TCON   TRCK         COMM

# hash mapping FLAC tag names to MP3 frames
our %MP3frames = (
    'ALBUM'       => 'TALB',
    'ARTIST'      => 'TPE1',
    'COMMENT'     => 'COMM',
    'DATE'        => 'TYER',
    'GENRE'       => 'TCON',
    'TITLE'       => 'TIT2',
    'TRACKNUMBER' => 'TRCK',
);

use vars qw (
  $flag_info
  $flag_debug
  $flag_tagsonly
  $flag_force
);

# Catch interupts (SIGINT)
$SIG{INT} = \&INT_Handler;

GetOptions(
    "quiet!"    => \$flag_info,
    "debug!"    => \$flag_debug,
    "tagsonly!" => \$flag_tagsonly,
    "force!"    => \$flag_force
);

# info flag is the inverse of --quiet
$flag_info = !$flag_info;

# Do I need to set the default value of any options? Or does GetOptions handle it?
# If I do, what's the "best" way to do it?

my ( $srcdirroot, $destdirroot ) = @ARGV;

showusage() if ( !defined $srcdirroot || !defined $destdirroot );

die "Source directory not found: $srcdirroot\n"
  unless -d $srcdirroot;

# count all flac files in srcdir
# Display a progress report after each file, e.g. Processed 367/4394 files
# Possibly do some timing and add a Estimated Time Remaining
# Will need to only count files that are going to be processed. Hmmm could get complicated.

find_files( $srcdirroot, $destdirroot, $srcdirroot );

1;
## End of main program

sub find_files {
    my ( $srcdirroot, $destdirroot, $srcdir ) = @_;

    $::flag_info && msg("Processing directory: $srcdir\n");

    # remove the src root directory from the beginning
    # of the current directory to give the additional
    # path information to be added to the destination root.
    # Try to create the new destination directory.
    ( my $extra_path = $srcdir ) =~ s/^\Q$srcdirroot\E//;
    my $destdir = $destdirroot . $extra_path;

    # get all directory entries
    opendir( SRCDIR, $srcdir ) or die "Couldn't open directory $srcdir\n";
    my @direntries = readdir(SRCDIR)
      or die "Couldn't read directory entries for directory $srcdir\n";
    closedir(SRCDIR);

    # get all target files within the present directory
    my @target_files = map { $_->[1] }    # extract pathnames
      map { [ $_, "$srcdir/$_" ] }        # form (name, path)
      sort                                # sort the entries (does this work?)
      grep { /\.flac$/ }                  # just flac files
      @direntries;

    # get all subdirs of the present directory
    my @subdirs = map { $_->[1] }         # extract pathnames
      grep { -d $_->[1] }                 # only directories
      map { [ $_, "$srcdir/$_" ] }        # form (name, path)
      sort                                # sort the entries (does this work?)
      grep { !/^\.\.?$/ }                 # not . or ..
      @direntries;

    # Create the destination directory if it doesn't already exist
    mkpath($destdir)
      or die "Can't create directory $destdir\n"
      unless -d $destdir;

    # process all files found in this directory
    foreach my $srcfilename (@target_files) {
        if ($::flag_debug) {
            msg("target_files: ");
            print Dumper @target_files;
            $::flag_debug && msg("srcfilename: $srcfilename\n");
            $::flag_debug && msg("destdir: $destdir\n");
        }
        convert_file( $srcfilename, $destdir );

        # The following construct generates silly warnings so I've removed it
        # Suggested by Darren Warner <darren@dazwin.com>
        # eval convert_file($srcfilename, $destdir);
        # warn($@) if $@;
    }

    # process any subdirs of present directory
    foreach my $srcsubdir (@subdirs) {
        &find_files( $srcdirroot, $destdirroot, $srcsubdir );
    }
}

sub showusage {
        print <<"EOT";
Usage: $0 [--quiet] [--debug] [--tagsonly] [--force] <flacdir> <mp3dir>
    --quiet         Disable informational output to stdout
    --debug         Enable debugging output. For developers only!
    --tagsonly      Don't do any transcoding - just update tags
    --force         Force transcoding and tag update even if not required
EOT
    exit 0;
}

sub msg {
    my $msg = shift;
    print "$msg";
}

sub convert_file {
    my ( $srcfilename, $destdir ) = @_;

    # To do:
    #   Compare tags even if src and dest file have same timestamp
    #   Use command-line switches to override default behaviour

    # get srcfile timestamp
    my $srcstat = stat($srcfilename);
    my $deststat;

    my $srcRelPath = File::Spec->abs2rel( $srcfilename, $srcdirroot );

    my $destPath = File::Spec->rel2abs( $srcRelPath, $destdirroot );

    my ( $fbase, $fdir, $fext ) = fileparse( $destPath, '\.flac$' );
    my $destfilename = $fdir . $fbase . ".mp3";

    $::flag_debug && msg("srcfile: $srcfilename\n");
    $::flag_debug && msg("destfile: $destfilename\n");

    # create object to access flac tags
    my $srcfile = Audio::FLAC::Header->new($srcfilename);

    # Get tags from flac file
    my $srcframes = $srcfile->tags();

    $::flag_debug && print "Tags from source file:\n" . Dumper $srcframes;

    # hash to hold tags that will be updated
    my %changedframes;

    # weed out tags not valid in destfile
    foreach my $frame ( keys %$srcframes ) {
        if ( $MP3frames{$frame} ) {
            $changedframes{$frame} = $srcframes->{$frame};
        }
    }

    if ($::flag_debug) {
        print "Valid Tags from source file:\n";
        print Dumper \%changedframes;
    }

    # File Processing flags
    my $pf_exists    = 0;
    my $pf_tags      = 0;
    my $pf_timestamp = 1;

    $::flag_debug && msg("destfilename: $destfilename\n");

    # if destfile already exists
    if ( -e $destfilename ) {

        $pf_exists = 1;

        $::flag_debug && msg("destfile exists: $destfilename\n");

        # get destfile timestamp
        $deststat = stat($destfilename);

        my $srcmodtime  = scalar $srcstat->mtime;
        my $destmodtime = scalar $deststat->mtime;

        if ($::flag_debug) {
            print("srcfile mtime:  $srcmodtime\n");
            print("destfile mtime: $destmodtime\n");
        }

        # Don't process the file if srcfile timestamp is earlier than destfile
        # or tags are different
        if ( $srcmodtime <= $destmodtime ) {
            $pf_timestamp = 0;
        }

        $::flag_debug && msg("pf_timestamp: $pf_timestamp\n");

        # If the file dates are the same
        if ( !$pf_timestamp ) {

            # Compare tags; build hash of changed tags;
            # if hash empty, process the file

            my $mp3 = MP3::Tag->new($destfilename);

            # If an ID3v2 tag is found
            if ( exists $mp3->{ID3v2} ) {

                # loop over all valid destfile frames
                foreach my $frame ( keys %MP3frames ) {

                    $::flag_debug && msg("frame is $frame\n");

             # To do: Check the frame is valid
             # Specifically, make sure the GENRE is one of the standard ID3 tags
                    my $method = $MP3frames{$frame};

                    $::flag_debug && msg("method is $method\n");

                    # Check for tag in destfile
                    my ( $destframe, $notused ) =
                      $mp3->{ID3v2}->get_frame($method);
                    $::flag_debug
                      && msg("destframe: $destframe\nnotused: $notused\n");

                    if ( $::flag_debug ) {
                    	my $framedata = MP3::Tag::what_data( "", $method );
	                if ( ref $framedata ) {
	                    if ( $#$framedata == 0 ) {
	                        msg("$method is a text frame\n");
	                    }
	                    else {
                                msg("$method is a complex frame\n");
                            }
                        }
                        else {
                            msg("$method is an other frame\n");
                        }
                    }

                    # Check for undefined frame
                    if ( !defined $destframe ) {
                        $destframe = '';
                    }
                    else {

          # Bug: AudioFile::Info returns track as numeric. FLAC returns a string
          # 3 <> 03 so the track tag will always appear modified
                        if ( $frame eq "TRACKNUMBER" ) {
                            if ( $destframe < 10 ) {
                                $destframe = sprintf( "%02u", $destframe );
                            }
                        }
                    }

                    $::flag_debug && msg("destframe value: $destframe\n");

                    # get tag from srcfile
                    my $srcframe = $changedframes{$frame};

                    $srcframe = '' if ( !defined $srcframe );

                    $::flag_debug && msg("srcframe value: $srcframe\n");

                    # If frames are the same...
                    if ( $destframe eq $srcframe ) {

                        # remove from frames to be written hash
                        delete( $changedframes{$frame} );
                    }
                    else {
                        $pf_tags = 1;
                    }
                }
            }
        }
    }

    if ($::flag_debug) {
        msg("pf_exists:    $pf_exists\n");
        msg("pf_tags:      $pf_tags\n");
        msg("pf_timestamp: $pf_timestamp\n");
	}		

	if ($::flag_debug) {
		print "Frames to be written to dest file:\n";
		print Dumper \%changedframes;
	}


	
	if (!$pf_exists || $pf_timestamp || $pf_tags || $::flag_force) {		
		$::flag_info && msg("Processing \"$fbase$fext\"\n");

		if ($::flag_force || (!$::flag_tagsonly && (!$pf_exists || ($pf_exists && !$pf_tags)))) {
			# Building command used to convert file (tagging done afterwards)
			
			# Needs some work on quoting filenames containing special characters
			my $quotedsrc = $srcfilename;
			my $quoteddest = $destfilename;
			my $convert_command = "$flaccmd @flacargs \"$quotedsrc\"" .
				"| $lamecmd @lameargs - \"$quoteddest\"";
	
			$::flag_debug && msg("$convert_command\n");

			
			# Convert the file
			my $exit_value = system ($convert_command);
		
			$::flag_debug && msg("Exit value from convert command: $exit_value\n");
		
			if ($exit_value) {
				print("$convert_command failed with exit code $exit_value\n");
				# delete the destfile if it exists
				unlink $destfilename;
				# should check exit status of this command
			
				exit($exit_value);
			}
			# the destfile now exists!
			$pf_exists = 1;
		}		

		# Write the tags to the converted file
		if ($pf_exists && ($pf_tags || $pf_timestamp) || $::flag_force) {

			$::flag_debug && msg("Writing frames to file\n");

			my $mp3 = MP3::Tag->new($destfilename);
			# Remove any existing tags
			$mp3->{ID3v2}->remove_tag if exists $mp3->{ID3v2};
			# Create a new tag
			$mp3->new_tag("ID3v2");

			foreach my $frame (keys %changedframes) {

				$::flag_debug && msg("changedframe is $frame\n");
			
				# To do: Check the frame is valid
				# Specifically, make sure the GENRE is one of the standard ID3 tags
				my $method = $MP3frames{$frame};

				$::flag_debug && msg("method is $method\n");

				my $framestring = $changedframes{$frame};

				$::flag_debug && msg("Setting $frame = $framestring\n");
				
				# COMM is a Complex frame so needs to be treated differently.
				if ($method eq "COMM") {
					$mp3->{"ID3v2"}->add_frame($method, 'ENG', 'Short text', $framestring);
				} else {
					$mp3->{"ID3v2"}->add_frame($method, $framestring);
				}
			}
			
			$mp3->{ID3v2}->write_tag;
			
			$mp3->close();

				
			# should optionally reset the destfile timestamp to the same as the srcfile	
			utime $srcstat->mtime, $srcstat->mtime, $destfilename;
		}
	}
}

sub INT_Handler {
	my $signame = shift;
	die "Exited with SIG$signame\n";
}

# vim:set tabstop=3:
